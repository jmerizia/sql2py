import argparse
import os
import sys
from typing import List, Tuple, Union, TypedDict

from sqlgood.parse_sqlite import parse_query_types
from sqlgood.parse_sqlite import get_db_schema_text


class SQLGoodError(Exception):
    pass


def to_snake_case(description: str) -> str:
    if description.strip()[0].isnumeric():
        raise SQLGoodError('Description should not contain leading numeric characters')
    words = description.split()
    words = [word.strip().lower() for word in words]
    words = [word for word in words if len(word) > 0 and word.isalnum()]
    name = '_'.join(words)
    name = ''.join(c for c in name if c.isalnum() or c == '_')
    return name


def generate_function(description: str,
                      sql_query: str,
                      schema_text: str,
                      is_async: bool = False) -> str:

    template = \
'''ReturnType_<<<NAME>>> = <<<TYPE_HINT>>>

def <<<NAME>>>(<<<PARAMS>>>) -> ReturnType_<<<NAME>>>:
    \'\'\'
    <<<DESCRIPTION>>>
    ---
    SQL: <<<SQL_QUERY>>>
    \'\'\'

    cur = con.cursor()
    cur.execute('<<<SQL_QUERY>>>', <<<BINDINGS>>>)
    res = []
    output_names = <<<OUTPUT_NAME_LIST>>>
    for row in cur.fetchall():
        row_dict = dict()
        for k, v in zip(output_names, row):
            row_dict[k] = v
        res.append(row_dict)
    <<<RETURN_STATEMENT>>>'''

    inputs, outputs = parse_query_types(sql_query, schema_text)
    name = to_snake_case(description)

    params = ', '.join(f'{c["name"]}: {c["type"]}' for c in inputs)

    if len(inputs) > 0:
        bindings = '(' + ', '.join(c["name"] for c in inputs) + ',)'
    else:
        bindings = ''
    output_name_list = '[' + ', '.join([f'\'{c["name"]}\'' for c in outputs]) + ']'

    if len(outputs) > 0:
        items: List[str] = []
        for c in outputs:
            nam, typ = c['name'], c['type']
            items.append(f'\'{nam}\': {typ}')
        typed_dict = '{' + ', '.join(items) + '}'
        type_hint = f'List[TypedDict(\'ReturnType_{name}\', {typed_dict})]'
        return_statement = 'return res'
    else:
        type_hint = 'None'
        return_statement = 'return None'

    template = template.replace('<<<NAME>>>', name)
    template = template.replace('<<<SQL_QUERY>>>', sql_query)
    template = template.replace('<<<PARAMS>>>', params)
    template = template.replace('<<<DESCRIPTION>>>', description)
    template = template.replace('<<<BINDINGS>>>', bindings)
    template = template.replace('<<<OUTPUT_NAME_LIST>>>', output_name_list)
    template = template.replace('<<<TYPE_HINT>>>', type_hint)
    template = template.replace('<<<RETURN_STATEMENT>>>', return_statement)
    return template


class QueryInfo(TypedDict):
    desc: str
    sql: str

def read_good_file(filename: str) -> List[QueryInfo]:
    if not os.path.exists(filename):
        raise SQLGoodError(f'No such file \'{filename}\'.')

    with open(filename, 'r') as f:
        lines = list(f)

    pairs: List[QueryInfo] = []
    last_desc: Union[None, str] = None
    for idx, line in enumerate(lines):
        s = lines[idx].strip()
        if len(s) == 0:
            continue
        if s.startswith('--'):
            # description
            if last_desc is None:
                last_desc = s[2:].strip()
            else:
                raise SQLGoodError(f'Expected SQL statement on line {idx}.')
        else:
            # SQL statement
            if last_desc is not None:
                pairs.append({
                    'desc': last_desc,
                    'sql': s.strip()
                })
                last_desc = None
            else:
                raise SQLGoodError(f'Expected comment description on line {idx}.')

    return pairs


def generate(input_filename: str,
             output_filename: str,
             db_filename: str) -> None:

    template = \
'''# This file has been generated by SQLGood. DO NOT EDIT MANUALLY!

import sqlite3
from typing import List, TypedDict

con = sqlite3.connect(<<<DB_FILENAME>>>)


<<<FUNCTIONS>>>'''

    schema_text = get_db_schema_text(db_filename=db_filename)
    queries = read_good_file(input_filename)
    functions = []
    for query in queries:
        function = generate_function(description=query['desc'],
                                     sql_query=query['sql'],
                                     schema_text=schema_text,
                                     is_async=False)
        functions.append(function)

    template = template.replace('<<<DB_FILENAME>>>', db_filename)
    template = template.replace('<<<FUNCTIONS>>>', '\n\n'.join(functions))

    with open(output_filename, 'w') as f:
        f.write(template)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Convert SQLite queries to Python functions.')
    parser.add_argument('-i', '--input',
                        type=str,
                        help='the input SQL file to parse',
                        default='good.sql')
    parser.add_argument('-o', '--output',
                        type=str,
                        help='the output Python file to generate',
                        default='queries.py')
    parser.add_argument('-f', '--db-filename',
                        type=str,
                        help='the SQLite database filename',
                        required=True)
    args = parser.parse_args()
    generate(input_filename=args.input,
             output_filename=args.output,
             db_filename=args.db_filename)

