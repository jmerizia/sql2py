# Generated from Postgresql.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3-")
        buf.write("\u00c2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\3\2\3\2\3\2\7")
        buf.write("\2\62\n\2\f\2\16\2\65\13\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\5\3>\n\3\3\4\3\4\3\4\3\4\3\4\5\4E\n\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\5\6V\n\6")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7d")
        buf.write("\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\t\7\ty\n\t\f\t\16\t|\13\t\3\t")
        buf.write("\3\t\3\t\3\n\3\n\3\13\3\13\3\13\7\13\u0086\n\13\f\13\16")
        buf.write("\13\u0089\13\13\3\13\5\13\u008c\n\13\3\f\3\f\3\r\3\r\3")
        buf.write("\16\3\16\3\16\6\16\u0095\n\16\r\16\16\16\u0096\3\17\3")
        buf.write("\17\3\17\3\20\3\20\3\20\7\20\u009f\n\20\f\20\16\20\u00a2")
        buf.write("\13\20\3\21\3\21\3\21\5\21\u00a7\n\21\3\21\3\21\5\21\u00ab")
        buf.write("\n\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u00b4\n")
        buf.write("\22\3\22\3\22\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26")
        buf.write("\3\27\3\27\3\27\2\2\30\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write("\34\36 \"$&(*,\2\5\5\2\24\25\32\32\35\35\6\2\t\t$%*+-")
        buf.write("-\4\2\6\6\n\n\2\u00c1\2.\3\2\2\2\4=\3\2\2\2\6?\3\2\2\2")
        buf.write("\bK\3\2\2\2\nO\3\2\2\2\fW\3\2\2\2\16e\3\2\2\2\20k\3\2")
        buf.write("\2\2\22\u0080\3\2\2\2\24\u008b\3\2\2\2\26\u008d\3\2\2")
        buf.write("\2\30\u008f\3\2\2\2\32\u0091\3\2\2\2\34\u0098\3\2\2\2")
        buf.write("\36\u009b\3\2\2\2 \u00a3\3\2\2\2\"\u00ac\3\2\2\2$\u00b7")
        buf.write("\3\2\2\2&\u00b9\3\2\2\2(\u00bb\3\2\2\2*\u00bd\3\2\2\2")
        buf.write(",\u00bf\3\2\2\2.\63\5\4\3\2/\60\7\3\2\2\60\62\5\4\3\2")
        buf.write("\61/\3\2\2\2\62\65\3\2\2\2\63\61\3\2\2\2\63\64\3\2\2\2")
        buf.write("\64\3\3\2\2\2\65\63\3\2\2\2\66>\5\6\4\2\67>\5\b\5\28>")
        buf.write("\5\n\6\29>\5\f\7\2:>\5\16\b\2;>\5\20\t\2<>\5\22\n\2=\66")
        buf.write("\3\2\2\2=\67\3\2\2\2=8\3\2\2\2=9\3\2\2\2=:\3\2\2\2=;\3")
        buf.write("\2\2\2=<\3\2\2\2>\5\3\2\2\2?@\7\22\2\2@D\7\23\2\2AB\7")
        buf.write("\30\2\2BC\7\26\2\2CE\7\31\2\2DA\3\2\2\2DE\3\2\2\2EF\3")
        buf.write("\2\2\2FG\5\30\r\2GH\7\4\2\2HI\5\32\16\2IJ\7\5\2\2J\7\3")
        buf.write("\2\2\2KL\7\37\2\2LM\7\23\2\2MN\7*\2\2N\t\3\2\2\2OP\7\17")
        buf.write("\2\2PQ\5\24\13\2QR\7\21\2\2RU\5\30\r\2ST\7 \2\2TV\5\"")
        buf.write("\22\2US\3\2\2\2UV\3\2\2\2V\13\3\2\2\2WX\7!\2\2XY\7\"\2")
        buf.write("\2YZ\5\30\r\2Z[\7\4\2\2[\\\5\24\13\2\\]\7\5\2\2]^\7#\2")
        buf.write("\2^_\7\4\2\2_`\5\36\20\2`c\7\5\2\2ab\7\34\2\2bd\7*\2\2")
        buf.write("ca\3\2\2\2cd\3\2\2\2d\r\3\2\2\2ef\7\20\2\2fg\7\21\2\2")
        buf.write("gh\5\30\r\2hi\7 \2\2ij\5\"\22\2j\17\3\2\2\2kl\7&\2\2l")
        buf.write("m\5\30\r\2mn\7)\2\2no\5\26\f\2op\7\6\2\2pz\5$\23\2qr\7")
        buf.write("\7\2\2rs\5\30\r\2st\7)\2\2tu\5\26\f\2uv\7\6\2\2vw\5$\23")
        buf.write("\2wy\3\2\2\2xq\3\2\2\2y|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{")
        buf.write("}\3\2\2\2|z\3\2\2\2}~\7 \2\2~\177\5\"\22\2\177\21\3\2")
        buf.write("\2\2\u0080\u0081\3\2\2\2\u0081\23\3\2\2\2\u0082\u0087")
        buf.write("\5\26\f\2\u0083\u0084\7\7\2\2\u0084\u0086\5\26\f\2\u0085")
        buf.write("\u0083\3\2\2\2\u0086\u0089\3\2\2\2\u0087\u0085\3\2\2\2")
        buf.write("\u0087\u0088\3\2\2\2\u0088\u008c\3\2\2\2\u0089\u0087\3")
        buf.write("\2\2\2\u008a\u008c\7\b\2\2\u008b\u0082\3\2\2\2\u008b\u008a")
        buf.write("\3\2\2\2\u008c\25\3\2\2\2\u008d\u008e\7*\2\2\u008e\27")
        buf.write("\3\2\2\2\u008f\u0090\7*\2\2\u0090\31\3\2\2\2\u0091\u0094")
        buf.write("\5\34\17\2\u0092\u0093\7\7\2\2\u0093\u0095\5\34\17\2\u0094")
        buf.write("\u0092\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0094\3\2\2\2")
        buf.write("\u0096\u0097\3\2\2\2\u0097\33\3\2\2\2\u0098\u0099\7*\2")
        buf.write("\2\u0099\u009a\5 \21\2\u009a\35\3\2\2\2\u009b\u00a0\5")
        buf.write("$\23\2\u009c\u009d\7\7\2\2\u009d\u009f\5$\23\2\u009e\u009c")
        buf.write("\3\2\2\2\u009f\u00a2\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0")
        buf.write("\u00a1\3\2\2\2\u00a1\37\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a3")
        buf.write("\u00a6\t\2\2\2\u00a4\u00a5\7\26\2\2\u00a5\u00a7\7\27\2")
        buf.write("\2\u00a6\u00a4\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00aa")
        buf.write("\3\2\2\2\u00a8\u00a9\7\33\2\2\u00a9\u00ab\7\36\2\2\u00aa")
        buf.write("\u00a8\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab!\3\2\2\2\u00ac")
        buf.write("\u00b3\5$\23\2\u00ad\u00b4\5&\24\2\u00ae\u00b4\5*\26\2")
        buf.write("\u00af\u00b4\5,\27\2\u00b0\u00b4\7\'\2\2\u00b1\u00b4\7")
        buf.write("(\2\2\u00b2\u00b4\5(\25\2\u00b3\u00ad\3\2\2\2\u00b3\u00ae")
        buf.write("\3\2\2\2\u00b3\u00af\3\2\2\2\u00b3\u00b0\3\2\2\2\u00b3")
        buf.write("\u00b1\3\2\2\2\u00b3\u00b2\3\2\2\2\u00b4\u00b5\3\2\2\2")
        buf.write("\u00b5\u00b6\5$\23\2\u00b6#\3\2\2\2\u00b7\u00b8\t\3\2")
        buf.write("\2\u00b8%\3\2\2\2\u00b9\u00ba\t\4\2\2\u00ba\'\3\2\2\2")
        buf.write("\u00bb\u00bc\7\13\2\2\u00bc)\3\2\2\2\u00bd\u00be\7\f\2")
        buf.write("\2\u00be+\3\2\2\2\u00bf\u00c0\7\r\2\2\u00c0-\3\2\2\2\17")
        buf.write("\63=DUcz\u0087\u008b\u0096\u00a0\u00a6\u00aa\u00b3")
        return buf.getvalue()


class PostgresqlParser ( Parser ):

    grammarFileName = "Postgresql.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'('", "')'", "'='", "','", "'*'", 
                     "'?'", "'=='", "'!='", "'>'", "'<'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "WS", "K_SELECT", "K_DELETE", "K_FROM", "K_CREATE", 
                      "K_TABLE", "K_INTEGER", "K_TEXT", "K_NOT", "K_NULL", 
                      "K_IF", "K_EXISTS", "K_SERIAL", "K_PRIMARY", "K_RETURNING", 
                      "K_BOOLEAN", "K_KEY", "K_DROP", "K_WHERE", "K_INSERT", 
                      "K_INTO", "K_VALUES", "K_TRUE", "K_FALSE", "K_UPDATE", 
                      "K_AND", "K_OR", "K_SET", "ID", "INT", "NEWLINE", 
                      "STRING" ]

    RULE_queries = 0
    RULE_query = 1
    RULE_create_query = 2
    RULE_drop_query = 3
    RULE_select_query = 4
    RULE_insert_query = 5
    RULE_delete_query = 6
    RULE_update_query = 7
    RULE_empty_query = 8
    RULE_column_refs = 9
    RULE_column_ref = 10
    RULE_table_ref = 11
    RULE_column_defs = 12
    RULE_column_def = 13
    RULE_column_values = 14
    RULE_column_type = 15
    RULE_simple_expr = 16
    RULE_atom = 17
    RULE_is_eq = 18
    RULE_neq = 19
    RULE_gt = 20
    RULE_lt = 21

    ruleNames =  [ "queries", "query", "create_query", "drop_query", "select_query", 
                   "insert_query", "delete_query", "update_query", "empty_query", 
                   "column_refs", "column_ref", "table_ref", "column_defs", 
                   "column_def", "column_values", "column_type", "simple_expr", 
                   "atom", "is_eq", "neq", "gt", "lt" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    WS=12
    K_SELECT=13
    K_DELETE=14
    K_FROM=15
    K_CREATE=16
    K_TABLE=17
    K_INTEGER=18
    K_TEXT=19
    K_NOT=20
    K_NULL=21
    K_IF=22
    K_EXISTS=23
    K_SERIAL=24
    K_PRIMARY=25
    K_RETURNING=26
    K_BOOLEAN=27
    K_KEY=28
    K_DROP=29
    K_WHERE=30
    K_INSERT=31
    K_INTO=32
    K_VALUES=33
    K_TRUE=34
    K_FALSE=35
    K_UPDATE=36
    K_AND=37
    K_OR=38
    K_SET=39
    ID=40
    INT=41
    NEWLINE=42
    STRING=43

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class QueriesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.QueryContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.QueryContext,i)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_queries

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueries" ):
                listener.enterQueries(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueries" ):
                listener.exitQueries(self)




    def queries(self):

        localctx = PostgresqlParser.QueriesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_queries)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.query()
            self.state = 49
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PostgresqlParser.T__0:
                self.state = 45
                self.match(PostgresqlParser.T__0)
                self.state = 46
                self.query()
                self.state = 51
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def create_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Create_queryContext,0)


        def drop_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Drop_queryContext,0)


        def select_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Select_queryContext,0)


        def insert_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Insert_queryContext,0)


        def delete_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Delete_queryContext,0)


        def update_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Update_queryContext,0)


        def empty_query(self):
            return self.getTypedRuleContext(PostgresqlParser.Empty_queryContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)




    def query(self):

        localctx = PostgresqlParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        try:
            self.state = 59
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PostgresqlParser.K_CREATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 52
                self.create_query()
                pass
            elif token in [PostgresqlParser.K_DROP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.drop_query()
                pass
            elif token in [PostgresqlParser.K_SELECT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 54
                self.select_query()
                pass
            elif token in [PostgresqlParser.K_INSERT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 55
                self.insert_query()
                pass
            elif token in [PostgresqlParser.K_DELETE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 56
                self.delete_query()
                pass
            elif token in [PostgresqlParser.K_UPDATE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 57
                self.update_query()
                pass
            elif token in [PostgresqlParser.EOF, PostgresqlParser.T__0]:
                self.enterOuterAlt(localctx, 7)
                self.state = 58
                self.empty_query()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CREATE(self):
            return self.getToken(PostgresqlParser.K_CREATE, 0)

        def K_TABLE(self):
            return self.getToken(PostgresqlParser.K_TABLE, 0)

        def table_ref(self):
            return self.getTypedRuleContext(PostgresqlParser.Table_refContext,0)


        def column_defs(self):
            return self.getTypedRuleContext(PostgresqlParser.Column_defsContext,0)


        def K_IF(self):
            return self.getToken(PostgresqlParser.K_IF, 0)

        def K_NOT(self):
            return self.getToken(PostgresqlParser.K_NOT, 0)

        def K_EXISTS(self):
            return self.getToken(PostgresqlParser.K_EXISTS, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_create_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_query" ):
                listener.enterCreate_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_query" ):
                listener.exitCreate_query(self)




    def create_query(self):

        localctx = PostgresqlParser.Create_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_create_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.match(PostgresqlParser.K_CREATE)
            self.state = 62
            self.match(PostgresqlParser.K_TABLE)
            self.state = 66
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PostgresqlParser.K_IF:
                self.state = 63
                self.match(PostgresqlParser.K_IF)
                self.state = 64
                self.match(PostgresqlParser.K_NOT)
                self.state = 65
                self.match(PostgresqlParser.K_EXISTS)


            self.state = 68
            self.table_ref()
            self.state = 69
            self.match(PostgresqlParser.T__1)
            self.state = 70
            self.column_defs()
            self.state = 71
            self.match(PostgresqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DROP(self):
            return self.getToken(PostgresqlParser.K_DROP, 0)

        def K_TABLE(self):
            return self.getToken(PostgresqlParser.K_TABLE, 0)

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_drop_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_query" ):
                listener.enterDrop_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_query" ):
                listener.exitDrop_query(self)




    def drop_query(self):

        localctx = PostgresqlParser.Drop_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_drop_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.match(PostgresqlParser.K_DROP)
            self.state = 74
            self.match(PostgresqlParser.K_TABLE)
            self.state = 75
            self.match(PostgresqlParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SELECT(self):
            return self.getToken(PostgresqlParser.K_SELECT, 0)

        def column_refs(self):
            return self.getTypedRuleContext(PostgresqlParser.Column_refsContext,0)


        def K_FROM(self):
            return self.getToken(PostgresqlParser.K_FROM, 0)

        def table_ref(self):
            return self.getTypedRuleContext(PostgresqlParser.Table_refContext,0)


        def K_WHERE(self):
            return self.getToken(PostgresqlParser.K_WHERE, 0)

        def simple_expr(self):
            return self.getTypedRuleContext(PostgresqlParser.Simple_exprContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_select_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_query" ):
                listener.enterSelect_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_query" ):
                listener.exitSelect_query(self)




    def select_query(self):

        localctx = PostgresqlParser.Select_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_select_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(PostgresqlParser.K_SELECT)
            self.state = 78
            self.column_refs()
            self.state = 79
            self.match(PostgresqlParser.K_FROM)
            self.state = 80
            self.table_ref()
            self.state = 83
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PostgresqlParser.K_WHERE:
                self.state = 81
                self.match(PostgresqlParser.K_WHERE)
                self.state = 82
                self.simple_expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INSERT(self):
            return self.getToken(PostgresqlParser.K_INSERT, 0)

        def K_INTO(self):
            return self.getToken(PostgresqlParser.K_INTO, 0)

        def table_ref(self):
            return self.getTypedRuleContext(PostgresqlParser.Table_refContext,0)


        def column_refs(self):
            return self.getTypedRuleContext(PostgresqlParser.Column_refsContext,0)


        def K_VALUES(self):
            return self.getToken(PostgresqlParser.K_VALUES, 0)

        def column_values(self):
            return self.getTypedRuleContext(PostgresqlParser.Column_valuesContext,0)


        def K_RETURNING(self):
            return self.getToken(PostgresqlParser.K_RETURNING, 0)

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_insert_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_query" ):
                listener.enterInsert_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_query" ):
                listener.exitInsert_query(self)




    def insert_query(self):

        localctx = PostgresqlParser.Insert_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_insert_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.match(PostgresqlParser.K_INSERT)
            self.state = 86
            self.match(PostgresqlParser.K_INTO)
            self.state = 87
            self.table_ref()
            self.state = 88
            self.match(PostgresqlParser.T__1)
            self.state = 89
            self.column_refs()
            self.state = 90
            self.match(PostgresqlParser.T__2)
            self.state = 91
            self.match(PostgresqlParser.K_VALUES)
            self.state = 92
            self.match(PostgresqlParser.T__1)
            self.state = 93
            self.column_values()
            self.state = 94
            self.match(PostgresqlParser.T__2)
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PostgresqlParser.K_RETURNING:
                self.state = 95
                self.match(PostgresqlParser.K_RETURNING)
                self.state = 96
                self.match(PostgresqlParser.ID)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DELETE(self):
            return self.getToken(PostgresqlParser.K_DELETE, 0)

        def K_FROM(self):
            return self.getToken(PostgresqlParser.K_FROM, 0)

        def table_ref(self):
            return self.getTypedRuleContext(PostgresqlParser.Table_refContext,0)


        def K_WHERE(self):
            return self.getToken(PostgresqlParser.K_WHERE, 0)

        def simple_expr(self):
            return self.getTypedRuleContext(PostgresqlParser.Simple_exprContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_delete_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete_query" ):
                listener.enterDelete_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete_query" ):
                listener.exitDelete_query(self)




    def delete_query(self):

        localctx = PostgresqlParser.Delete_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_delete_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(PostgresqlParser.K_DELETE)
            self.state = 100
            self.match(PostgresqlParser.K_FROM)
            self.state = 101
            self.table_ref()
            self.state = 102
            self.match(PostgresqlParser.K_WHERE)
            self.state = 103
            self.simple_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UPDATE(self):
            return self.getToken(PostgresqlParser.K_UPDATE, 0)

        def table_ref(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.Table_refContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.Table_refContext,i)


        def K_SET(self, i:int=None):
            if i is None:
                return self.getTokens(PostgresqlParser.K_SET)
            else:
                return self.getToken(PostgresqlParser.K_SET, i)

        def column_ref(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.Column_refContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.Column_refContext,i)


        def atom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.AtomContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.AtomContext,i)


        def K_WHERE(self):
            return self.getToken(PostgresqlParser.K_WHERE, 0)

        def simple_expr(self):
            return self.getTypedRuleContext(PostgresqlParser.Simple_exprContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_update_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_query" ):
                listener.enterUpdate_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_query" ):
                listener.exitUpdate_query(self)




    def update_query(self):

        localctx = PostgresqlParser.Update_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_update_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(PostgresqlParser.K_UPDATE)
            self.state = 106
            self.table_ref()
            self.state = 107
            self.match(PostgresqlParser.K_SET)
            self.state = 108
            self.column_ref()
            self.state = 109
            self.match(PostgresqlParser.T__3)
            self.state = 110
            self.atom()
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PostgresqlParser.T__4:
                self.state = 111
                self.match(PostgresqlParser.T__4)
                self.state = 112
                self.table_ref()
                self.state = 113
                self.match(PostgresqlParser.K_SET)
                self.state = 114
                self.column_ref()
                self.state = 115
                self.match(PostgresqlParser.T__3)
                self.state = 116
                self.atom()
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 123
            self.match(PostgresqlParser.K_WHERE)
            self.state = 124
            self.simple_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Empty_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PostgresqlParser.RULE_empty_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmpty_query" ):
                listener.enterEmpty_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmpty_query" ):
                listener.exitEmpty_query(self)




    def empty_query(self):

        localctx = PostgresqlParser.Empty_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_empty_query)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_refsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_ref(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.Column_refContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.Column_refContext,i)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_refs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_refs" ):
                listener.enterColumn_refs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_refs" ):
                listener.exitColumn_refs(self)




    def column_refs(self):

        localctx = PostgresqlParser.Column_refsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_column_refs)
        self._la = 0 # Token type
        try:
            self.state = 137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PostgresqlParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                self.column_ref()
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PostgresqlParser.T__4:
                    self.state = 129
                    self.match(PostgresqlParser.T__4)
                    self.state = 130
                    self.column_ref()
                    self.state = 135
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [PostgresqlParser.T__5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.match(PostgresqlParser.T__5)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_refContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_ref" ):
                listener.enterColumn_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_ref" ):
                listener.exitColumn_ref(self)




    def column_ref(self):

        localctx = PostgresqlParser.Column_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_column_ref)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(PostgresqlParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_refContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_table_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_ref" ):
                listener.enterTable_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_ref" ):
                listener.exitTable_ref(self)




    def table_ref(self):

        localctx = PostgresqlParser.Table_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_table_ref)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(PostgresqlParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_defsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.Column_defContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.Column_defContext,i)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_defs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_defs" ):
                listener.enterColumn_defs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_defs" ):
                listener.exitColumn_defs(self)




    def column_defs(self):

        localctx = PostgresqlParser.Column_defsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_column_defs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.column_def()
            self.state = 146 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 144
                self.match(PostgresqlParser.T__4)
                self.state = 145
                self.column_def()
                self.state = 148 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==PostgresqlParser.T__4):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def column_type(self):
            return self.getTypedRuleContext(PostgresqlParser.Column_typeContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_def" ):
                listener.enterColumn_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_def" ):
                listener.exitColumn_def(self)




    def column_def(self):

        localctx = PostgresqlParser.Column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_column_def)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(PostgresqlParser.ID)
            self.state = 151
            self.column_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_valuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.AtomContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.AtomContext,i)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_values" ):
                listener.enterColumn_values(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_values" ):
                listener.exitColumn_values(self)




    def column_values(self):

        localctx = PostgresqlParser.Column_valuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_column_values)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.atom()
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PostgresqlParser.T__4:
                self.state = 154
                self.match(PostgresqlParser.T__4)
                self.state = 155
                self.atom()
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INTEGER(self):
            return self.getToken(PostgresqlParser.K_INTEGER, 0)

        def K_TEXT(self):
            return self.getToken(PostgresqlParser.K_TEXT, 0)

        def K_BOOLEAN(self):
            return self.getToken(PostgresqlParser.K_BOOLEAN, 0)

        def K_SERIAL(self):
            return self.getToken(PostgresqlParser.K_SERIAL, 0)

        def K_NOT(self):
            return self.getToken(PostgresqlParser.K_NOT, 0)

        def K_NULL(self):
            return self.getToken(PostgresqlParser.K_NULL, 0)

        def K_PRIMARY(self):
            return self.getToken(PostgresqlParser.K_PRIMARY, 0)

        def K_KEY(self):
            return self.getToken(PostgresqlParser.K_KEY, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_column_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_type" ):
                listener.enterColumn_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_type" ):
                listener.exitColumn_type(self)




    def column_type(self):

        localctx = PostgresqlParser.Column_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_column_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PostgresqlParser.K_INTEGER) | (1 << PostgresqlParser.K_TEXT) | (1 << PostgresqlParser.K_SERIAL) | (1 << PostgresqlParser.K_BOOLEAN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PostgresqlParser.K_NOT:
                self.state = 162
                self.match(PostgresqlParser.K_NOT)
                self.state = 163
                self.match(PostgresqlParser.K_NULL)


            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PostgresqlParser.K_PRIMARY:
                self.state = 166
                self.match(PostgresqlParser.K_PRIMARY)
                self.state = 167
                self.match(PostgresqlParser.K_KEY)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PostgresqlParser.AtomContext)
            else:
                return self.getTypedRuleContext(PostgresqlParser.AtomContext,i)


        def is_eq(self):
            return self.getTypedRuleContext(PostgresqlParser.Is_eqContext,0)


        def gt(self):
            return self.getTypedRuleContext(PostgresqlParser.GtContext,0)


        def lt(self):
            return self.getTypedRuleContext(PostgresqlParser.LtContext,0)


        def K_AND(self):
            return self.getToken(PostgresqlParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PostgresqlParser.K_OR, 0)

        def neq(self):
            return self.getTypedRuleContext(PostgresqlParser.NeqContext,0)


        def getRuleIndex(self):
            return PostgresqlParser.RULE_simple_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_expr" ):
                listener.enterSimple_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_expr" ):
                listener.exitSimple_expr(self)




    def simple_expr(self):

        localctx = PostgresqlParser.Simple_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_simple_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.atom()
            self.state = 177
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PostgresqlParser.T__3, PostgresqlParser.T__7]:
                self.state = 171
                self.is_eq()
                pass
            elif token in [PostgresqlParser.T__9]:
                self.state = 172
                self.gt()
                pass
            elif token in [PostgresqlParser.T__10]:
                self.state = 173
                self.lt()
                pass
            elif token in [PostgresqlParser.K_AND]:
                self.state = 174
                self.match(PostgresqlParser.K_AND)
                pass
            elif token in [PostgresqlParser.K_OR]:
                self.state = 175
                self.match(PostgresqlParser.K_OR)
                pass
            elif token in [PostgresqlParser.T__8]:
                self.state = 176
                self.neq()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 179
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(PostgresqlParser.INT, 0)

        def ID(self):
            return self.getToken(PostgresqlParser.ID, 0)

        def K_FALSE(self):
            return self.getToken(PostgresqlParser.K_FALSE, 0)

        def K_TRUE(self):
            return self.getToken(PostgresqlParser.K_TRUE, 0)

        def STRING(self):
            return self.getToken(PostgresqlParser.STRING, 0)

        def getRuleIndex(self):
            return PostgresqlParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = PostgresqlParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PostgresqlParser.T__6) | (1 << PostgresqlParser.K_TRUE) | (1 << PostgresqlParser.K_FALSE) | (1 << PostgresqlParser.ID) | (1 << PostgresqlParser.INT) | (1 << PostgresqlParser.STRING))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_eqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PostgresqlParser.RULE_is_eq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_eq" ):
                listener.enterIs_eq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_eq" ):
                listener.exitIs_eq(self)




    def is_eq(self):

        localctx = PostgresqlParser.Is_eqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_is_eq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            _la = self._input.LA(1)
            if not(_la==PostgresqlParser.T__3 or _la==PostgresqlParser.T__7):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PostgresqlParser.RULE_neq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNeq" ):
                listener.enterNeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNeq" ):
                listener.exitNeq(self)




    def neq(self):

        localctx = PostgresqlParser.NeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_neq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(PostgresqlParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PostgresqlParser.RULE_gt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGt" ):
                listener.enterGt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGt" ):
                listener.exitGt(self)




    def gt(self):

        localctx = PostgresqlParser.GtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_gt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.match(PostgresqlParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PostgresqlParser.RULE_lt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLt" ):
                listener.enterLt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLt" ):
                listener.exitLt(self)




    def lt(self):

        localctx = PostgresqlParser.LtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_lt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(PostgresqlParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





